# Fast Feedback Loops

Large-scale change is achieved iteratively and incrementally. When you break a problem into small steps, you create a lot of seams for feedback to enter the process. If your tools and processes are set up to inject that feedback, there's a higher likelihood that progress will get made faster. Additionally, it's easier to think about solutions to a series of small problems than it is to solve a big one. That's why it's often a good idea to iterate to the big solution via solving a lot of small and concrete problems.

## Resources

- [Limit Work In Process (WIP)](https://cloud.google.com/architecture/devops/devops-measurement-wip-limits)
- [Work in small batches](https://cloud.google.com/architecture/devops/devops-process-working-in-small-batches)
- [Introduction to the concept of fast feedback loops and its benefits](https://medium.com/@lucamezzalira/the-power-of-feedback-loops-f8e27e8ac25f)
- [Break down the problem into steps](https://github.com/97-things/97-things-every-programmer-should-know/tree/master/en/thing_47)
- [An argument against PRs](https://www.youtube.com/watch?v=ZlLZEQQBcFg)
- [Streamline change approval](https://cloud.google.com/architecture/devops/devops-process-streamlining-change-approval)
- [Keep build noise down](https://github.com/97-things/97-things-every-programmer-should-know/tree/master/en/thing_42)

### Refactoring

As it relates to refactoring, it is important to challenge yourself to make changes in small increments. If you break something without realizing it, then continue to pile on changes, it becomes difficult to figure out what exact change broke the system. See the [simplicity page](https://github.com/pragmint/best-practices/blob/main/adaptability/simplicity.md) for more foundational resources on refactoring.

- [Incremental refactoring](https://github.com/97-things/97-things-every-programmer-should-know/tree/master/en/thing_06)
- [Transformation Priority Premise](http://blog.cleancoder.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html)
