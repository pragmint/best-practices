# Catch Failure Early in the Process

The [teamwork](https://github.com/pragmint/best-practices/blob/main/teamwork/) and [inexpensive correctness verification](https://github.com/pragmint/best-practices/blob/main/inexpensive-correctness-verification/) sections outline a number of great strategies to catch failures early in the process (pairing, linting, automated testing, etc). As such, there aren't many other things to say on the topic. We decided to create this section anyways because we wanted to highlight the importance of pursuing this as a goal. By catching failure early, you're not only preventing issues, but you're getting rid of the time spent by your team trying to understand and resolve said issues as well. The value of catching failure early in the process can't be understated.

With all that being said, it's unrealistic to expect any meaningful software project to be completely free from defects. In fact, the act of attempting to prevent failures from making it to production can negatively affect an organization's [flow of work](https://github.com/pragmint/best-practices/blob/main/fun/flow.md#Flow-of-Work) if taken too far. Having a strong flow of work is more important than preventing failures for most projects (non safety critical projects). Some organizations have decreased the cost of failure so much (through [observability automation](https://github.com/pragmint/best-practices/blob/main/inexpensive-correctness-verification/observability.md) and a [fast flow of work](https://github.com/pragmint/best-practices/blob/main/fun/flow.md#Flow-of-Work)) that it becomes cheaper to introduce a failure than it would be to have all of those failure prevention processes in place. That doesn't mean those organizations have a flippant attitude towards failure prevention. It means they are hyper-aware of the costs associated with each process / tool aimed at failure prevention, and they pragmatically apply them.
